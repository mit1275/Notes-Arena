import { guid, Keys } from '@progress/kendo-react-common';
import { findId, findNextIdByCellIndex, findNextIdByRowIndex, getBodyElement, getHeaderElement, getNavigatableId, tableKeyboardNavigationTools as navigationTools } from './utils';
import { KEYBOARD_NAV_FILTER_COL_SUFFIX } from './constants';
/**
 * @hidden
 */
var onConstructor = function (options) {
    var navigatable = options.navigatable, contextStateRef = options.contextStateRef, navigationStateRef = options.navigationStateRef, idPrefix = options.idPrefix;
    // v.2: check if nested navigation
    if (navigatable) {
        contextStateRef.current = {
            activeId: '',
            level: 0
        };
        navigationStateRef.current = {
            activeElementIsFocused: false,
            prevNavigationIndexes: undefined,
            idPrefix: idPrefix || guid(),
            navigationMatrix: [],
            lastHeaderIndex: -1
        };
    }
};
/**
 * @hidden
 */
var onComponentDidMount = function (options) {
    var scope = options.scope, contextStateRef = options.contextStateRef, navigationStateRef = options.navigationStateRef;
    if (contextStateRef.current && navigationStateRef.current && scope) {
        generateMatrix(options);
        var firstId = navigationStateRef.current.navigationMatrix[0][0];
        var firstIdElement = navigationTools.getActiveElement(scope, firstId);
        if (firstId && firstIdElement) {
            contextStateRef.current.activeId = firstId;
            firstIdElement.setAttribute('tabIndex', '0');
        }
    }
};
/**
 * @hidden
 */
var onGetSnapshotBeforeUpdate = function (options) {
    var contextStateRef = options.contextStateRef, navigationStateRef = options.navigationStateRef, document = options.document;
    if (contextStateRef.current && navigationStateRef.current && document) {
        var activeElement = document.activeElement;
        var activeId = navigationTools.getNavigatableId(activeElement);
        if (activeId && activeId === contextStateRef.current.activeId) {
            navigationStateRef.current.activeElementIsFocused = true;
        }
    }
};
/**
 * @hidden
 */
var onComponentDidUpdate = function (options) {
    var scope = options.scope, contextStateRef = options.contextStateRef, navigationStateRef = options.navigationStateRef;
    generateMatrix(options);
    // check if nested navigation
    if (contextStateRef.current && navigationStateRef.current && scope) {
        var activeElement = navigationTools.getActiveElement(scope, contextStateRef.current.activeId);
        if (!activeElement) {
            var firstId = navigationStateRef.current.navigationMatrix[0][0];
            var firstIdElement = navigationTools.getActiveElement(scope, firstId);
            if (firstId && firstIdElement) {
                contextStateRef.current.activeId = firstId;
                firstIdElement.setAttribute('tabIndex', '0');
                if (navigationStateRef.current.activeElementIsFocused) {
                    firstIdElement.focus();
                }
            }
        }
        navigationStateRef.current.activeElementIsFocused = false;
    }
};
/**
 * @hidden
 */
var onFocus = function (event, options) {
    var contextStateRef = options.contextStateRef;
    if (event.isDefaultPrevented()) {
        return;
    }
    if (!contextStateRef.current) {
        return;
    }
    var focusedElement = event.target;
    var activeId = navigationTools.getNavigatableId(focusedElement);
    if (activeId && activeId !== contextStateRef.current.activeId) {
        var scope = navigationTools.getClosestScope(focusedElement);
        if (!scope) {
            return;
        }
        var prevElement = navigationTools.getActiveElement(scope, contextStateRef.current.activeId);
        if (prevElement) {
            prevElement.setAttribute('tabIndex', '-1');
        }
        focusedElement.setAttribute('tabIndex', '0');
        contextStateRef.current.activeId = activeId;
    }
};
/**
 * @hidden
 */
var onKeyDown = function (event, options) {
    var contextStateRef = options.contextStateRef, navigationStateRef = options.navigationStateRef;
    if (event.isDefaultPrevented()) {
        return;
    }
    if (!contextStateRef.current || !navigationStateRef.current) {
        return;
    }
    if (event.keyCode === Keys.esc) {
        // activate navigation
        var elementForFocus = navigationTools.getClosestNavigatableElement(event.target);
        navigationTools.focusElement({ elementForFocus: elementForFocus, event: event, contextStateRef: contextStateRef });
        return;
    }
    var element = event.target;
    var elementId = navigationTools.getNavigatableId(element);
    var dataLevel = navigationTools.getNavigatableLevel(element);
    var scope = navigationTools.getClosestScope(element);
    var matrix = navigationStateRef.current.navigationMatrix;
    if (dataLevel !== undefined && scope) {
        if (event.keyCode === Keys.enter) {
            // activate nested navigation or focus focusable element
            var navigatableElement = navigationTools.getNavigatableElement(element, { level: dataLevel + 1 });
            if (navigatableElement) {
                navigationTools.focusElement({
                    elementForFocus: navigatableElement,
                    event: event,
                    contextStateRef: contextStateRef,
                    prevElement: element
                });
                return;
            }
            else {
                var elementForFocus = navigationTools.getFocusableElements(element)[0];
                navigationTools.focusElement({ elementForFocus: elementForFocus, event: event, contextStateRef: contextStateRef, prevElement: element });
                return;
            }
        }
        if (event.keyCode === Keys.up ||
            event.keyCode === Keys.down ||
            event.keyCode === Keys.left ||
            event.keyCode === Keys.right) {
            var isReverse = event.keyCode === Keys.up || event.keyCode === Keys.left;
            var isVertical = event.keyCode === Keys.up || event.keyCode === Keys.down;
            var currentIdIndexes = void 0;
            if (navigationStateRef.current && navigationStateRef.current.prevNavigationIndexes) {
                var _a = navigationStateRef.current.prevNavigationIndexes, rowIndex = _a[0], cellIndex = _a[1];
                if (matrix[rowIndex][cellIndex] === elementId) {
                    currentIdIndexes = navigationStateRef.current.prevNavigationIndexes;
                }
                else {
                    currentIdIndexes = findId(matrix, elementId);
                }
            }
            else {
                currentIdIndexes = findId(matrix, elementId);
            }
            if (currentIdIndexes) {
                var rowIndex = currentIdIndexes[0], cellIndex = currentIdIndexes[1];
                var _b = isVertical ?
                    findNextIdByRowIndex(rowIndex, cellIndex, elementId, matrix, isReverse) :
                    findNextIdByCellIndex(rowIndex, cellIndex, elementId, matrix, isReverse), idForFocus = _b[0], currentIndexes = _b[1];
                if (idForFocus) {
                    var elementForFocus = navigationTools.getActiveElement(scope, idForFocus);
                    navigationTools.focusElement({ elementForFocus: elementForFocus, event: event, contextStateRef: contextStateRef, prevElement: element });
                    navigationStateRef.current.prevNavigationIndexes = currentIndexes;
                }
            }
        }
    }
};
/**
 * @hidden
 */
var generateHeaderMatrix = function (options) {
    var columns = options.columns, filterColumns = options.filterColumns, navigationStateRef = options.navigationStateRef;
    if (!navigationStateRef.current) {
        return;
    }
    var matrix = [];
    var maxDepth = 0;
    columns.forEach(function (column) { return maxDepth = Math.max(maxDepth, column.depth); });
    columns.forEach(function (column) {
        if (!matrix[column.depth]) {
            matrix[column.depth] = [];
        }
        matrix[column.depth][matrix[column.depth].length] = column.id;
        if (column.colSpan > 1) {
            for (var colSpan = 2; colSpan <= column.colSpan; colSpan++) {
                var colIndex = matrix[column.depth].length;
                matrix[column.depth][colIndex] = column.id;
            }
        }
        if (!column.children.length) {
            for (var depth = column.depth + 1; depth <= maxDepth; depth++) {
                if (!matrix[depth]) {
                    matrix[depth] = [];
                }
                var colIndex = matrix[depth].length;
                matrix[depth][colIndex] = column.id;
            }
        }
    });
    if (filterColumns) {
        filterColumns.forEach(function (col) {
            if (!matrix[maxDepth + 1]) {
                matrix[maxDepth + 1] = [];
            }
            var colIndex = matrix[maxDepth + 1].length;
            matrix[maxDepth + 1][colIndex] = "" + col.id + KEYBOARD_NAV_FILTER_COL_SUFFIX;
        });
    }
    navigationStateRef.current.navigationMatrix = matrix;
    navigationStateRef.current.lastHeaderIndex = matrix.length - 1;
};
/**
 * @hidden
 */
var generateRowMatrix = function (options) {
    var cellId = options.cellId, colSpan = options.colSpan, navigationStateRef = options.navigationStateRef, rowIndex = options.rowIndex;
    if (!navigationStateRef.current) {
        return;
    }
    var matrix = navigationStateRef.current.navigationMatrix;
    if (!matrix[rowIndex]) {
        matrix[rowIndex] = [];
    }
    for (var i = 1; i <= colSpan; i++) {
        matrix[rowIndex].push(cellId);
    }
};
/**
 * @hidden
 */
var generateMatrix = function (options) {
    var navigationStateRef = options.navigationStateRef, scope = options.scope;
    if (!navigationStateRef.current || !scope) {
        return;
    }
    var matrix = [];
    var thead = getHeaderElement(scope);
    var tbody = getBodyElement(scope);
    if (!thead || !tbody) {
        return;
    }
    var headerRows = Array.from(thead.children);
    var bodyRows = Array.from(tbody.children);
    headerRows.concat(bodyRows).forEach(function (row, rowIndex) {
        Array.from(row.children).forEach(function (cell) {
            var cellId = getNavigatableId(cell);
            if (!cellId) {
                return;
            } // cell is not navigatable
            var rowSpan = cell.rowSpan || 1;
            var cellSpan = cell.colSpan || 1;
            var cellIndex;
            for (var depth = rowIndex, maxDepth = rowIndex + rowSpan; depth < maxDepth; depth++) {
                if (!matrix[depth]) {
                    matrix[depth] = [];
                }
                if (cellIndex === undefined) {
                    var freeSlotIndex = matrix[depth].findIndex(function (mi) { return !mi; });
                    cellIndex = freeSlotIndex > -1 ? freeSlotIndex : matrix[depth].length;
                }
                matrix[depth][cellIndex] = cellId || '';
            }
            for (var depth = cellIndex + 1, maxDepth = cellIndex + cellSpan; depth < maxDepth; depth++) {
                matrix[rowIndex][depth] = cellId || '';
            }
        });
    });
    navigationStateRef.current.navigationMatrix = matrix.filter(function (row) { return !!row; });
    navigationStateRef.current.lastHeaderIndex = headerRows.length - 1;
};
/**
 * @hidden
 */
export var tableKeyboardNavigation = {
    onConstructor: onConstructor,
    onComponentDidMount: onComponentDidMount,
    onGetSnapshotBeforeUpdate: onGetSnapshotBeforeUpdate,
    onComponentDidUpdate: onComponentDidUpdate,
    onFocus: onFocus,
    onKeyDown: onKeyDown,
    generateHeaderMatrix: generateHeaderMatrix,
    generateRowMatrix: generateRowMatrix,
    generateMatrix: generateMatrix
};
//# sourceMappingURL=TableKeyboardNavigation.js.map